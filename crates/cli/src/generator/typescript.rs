//! TypeScript SDK generator
//!
//! Generates type-safe TypeScript SDKs from flag definitions.

use crate::error::{CliError, CliResult};
use crate::generator::Generator;
use serde_json::Value;
use std::fs;
use std::path::Path;

/// TypeScript SDK generator
pub struct TypeScriptGenerator;

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Convert snake_case to camelCase
    fn to_camel_case(s: &str) -> String {
        let mut result = String::new();
        let mut capitalize_next = false;
        for c in s.chars() {
            if c == '_' {
                capitalize_next = true;
            } else if capitalize_next {
                result.push(c.to_uppercase().next().unwrap_or(c));
                capitalize_next = false;
            } else {
                result.push(c);
            }
        }
        result
    }

    /// Get variation type name from flag name
    fn get_variation_type_name(flag_name: &str) -> String {
        let camel = Self::to_camel_case(flag_name);
        let mut chars = camel.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => first.to_uppercase().collect::<String>() + chars.as_str() + "Variation",
        }
    }

    /// Format default value for TypeScript code
    fn format_default_value(value: &Value) -> String {
        match value {
            Value::Bool(b) => b.to_string(),
            Value::Number(n) => n.to_string(),
            Value::String(s) => {
                // Check if it's a boolean string
                match s.as_str() {
                    "ON" | "true" => "true".to_string(),
                    "OFF" | "false" => "false".to_string(),
                    _ => format!("'{}'", s),
                }
            }
            _ => "false".to_string(), // Fallback
        }
    }

    /// Get default value from flag definition
    fn get_default_value(flag: &Value) -> &Value {
        flag.get("defaultValue").unwrap_or(&Value::Bool(false))
    }

    /// Generate types.ts file
    fn generate_types(&self, definitions: &Value) -> String {
        let empty_flags: Vec<Value> = Vec::new();
        let flags = definitions
            .get("flags")
            .and_then(|f| f.as_array())
            .unwrap_or(&empty_flags);

        let mut lines = vec![
            "/*!".to_string(),
            " * Generated by controlpath generate-sdk".to_string(),
            " * DO NOT EDIT - This file is auto-generated".to_string(),
            " */".to_string(),
            String::new(),
        ];

        // User interface
        lines.push("export interface User {".to_string());
        lines.push("  id: string;".to_string());
        lines.push("  [key: string]: any;".to_string());
        lines.push("}".to_string());
        lines.push(String::new());

        // Context interface
        lines.push("export interface Context {".to_string());
        lines.push("  environment?: string;".to_string());
        lines.push("  [key: string]: any;".to_string());
        lines.push("}".to_string());
        lines.push(String::new());

        // Generate variation types for multivariate flags
        for flag in flags {
            if let Some(flag_type) = flag.get("type").and_then(|t| t.as_str()) {
                if flag_type == "multivariate" {
                    if let Some(variations) = flag.get("variations").and_then(|v| v.as_array()) {
                        if let Some(flag_name) = flag.get("name").and_then(|n| n.as_str()) {
                            let variation_type_name = Self::get_variation_type_name(flag_name);
                            lines.push(format!("export type {} =", variation_type_name));
                            let variation_names: Vec<String> = variations
                                .iter()
                                .filter_map(|v| v.get("name").and_then(|n| n.as_str()))
                                .map(|n| format!("'{}'", n))
                                .collect();
                            if !variation_names.is_empty() {
                                lines.push(format!("  {}", variation_names.join(" |\n  ")));
                            }
                            lines.push(";".to_string());
                            lines.push(String::new());
                        }
                    }
                }
            }
        }

        // Generate FlagName union type
        let flag_names: Vec<String> = flags
            .iter()
            .filter_map(|f| f.get("name").and_then(|n| n.as_str()))
            .map(Self::to_camel_case)
            .map(|n| format!("'{}'", n))
            .collect();
        if !flag_names.is_empty() {
            lines.push("export type FlagName =".to_string());
            lines.push(format!("  {}", flag_names.join(" |\n  ")));
            lines.push(";".to_string());
            lines.push(String::new());
        }

        // Generate FlagReturnTypes mapped type
        lines.push("export type FlagReturnTypes = {".to_string());
        for flag in flags {
            if let Some(flag_name) = flag.get("name").and_then(|n| n.as_str()) {
                let camel_name = Self::to_camel_case(flag_name);
                if let Some(flag_type) = flag.get("type").and_then(|t| t.as_str()) {
                    if flag_type == "boolean" {
                        lines.push(format!("  {}: boolean;", camel_name));
                    } else if flag_type == "multivariate" {
                        let variation_type_name = Self::get_variation_type_name(flag_name);
                        lines.push(format!("  {}: {};", camel_name, variation_type_name));
                    }
                }
            }
        }
        lines.push("};".to_string());

        lines.join("\n")
    }

    /// Generate index.ts file (evaluator class)
    fn generate_evaluator(&self, definitions: &Value) -> String {
        let empty_flags: Vec<Value> = Vec::new();
        let flags = definitions
            .get("flags")
            .and_then(|f| f.as_array())
            .unwrap_or(&empty_flags);

        let mut lines = vec![
            "/*!".to_string(),
            " * Generated by controlpath generate-sdk".to_string(),
            " * DO NOT EDIT - This file is auto-generated".to_string(),
            " */".to_string(),
            String::new(),
            "import { Provider } from '@controlpath/runtime';".to_string(),
            "import { EvaluationContext } from '@openfeature/server-sdk';".to_string(),
            "import type { User, Context, FlagName, FlagReturnTypes } from './types';".to_string(),
            String::new(),
        ];

        // Import variation types
        let mut has_variations = false;
        for flag in flags {
            if let Some(flag_type) = flag.get("type").and_then(|t| t.as_str()) {
                if flag_type == "multivariate" {
                    if let Some(flag_name) = flag.get("name").and_then(|n| n.as_str()) {
                        let variation_type_name = Self::get_variation_type_name(flag_name);
                        lines.push(format!(
                            "import type {{ {} }} from './types';",
                            variation_type_name
                        ));
                        has_variations = true;
                    }
                }
            }
        }
        if has_variations {
            lines.push(String::new());
        }

        // Evaluator class
        lines.push("export class Evaluator {".to_string());
        lines.push("  private provider: Provider;".to_string());
        lines.push("  private initialized: boolean = false;".to_string());
        lines.push("  private setUser?: User;".to_string());
        lines.push("  private setContextValue?: Context;".to_string());
        lines.push(String::new());
        lines.push("  constructor() {".to_string());
        lines.push("    this.provider = new Provider();".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  async init(options?: { artifact?: string }): Promise<void> {".to_string());
        lines.push("    if (options?.artifact) {".to_string());
        lines.push("      await this.provider.loadArtifact(options.artifact);".to_string());
        lines.push("    }".to_string());
        lines.push("    this.initialized = true;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  private async ensureInitialized(): Promise<void> {".to_string());
        lines.push("    if (!this.initialized) {".to_string());
        lines.push("      await this.init();".to_string());
        lines.push("    }".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  setContext(user: User, context?: Context): void {".to_string());
        lines.push("    this.setUser = user;".to_string());
        lines.push("    this.setContextValue = context;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  clearContext(): void {".to_string());
        lines.push("    this.setUser = undefined;".to_string());
        lines.push("    this.setContextValue = undefined;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());

        // Generate methods for each flag
        for flag in flags {
            self.generate_flag_method(&mut lines, flag);
        }

        // Generate batch evaluation methods
        self.generate_batch_methods(&mut lines, flags);

        // Helper methods
        lines.push(
            "  private resolveContext(user?: User, context?: Context): EvaluationContext | null {"
                .to_string(),
        );
        lines.push("    const resolvedUser = user ?? this.setUser;".to_string());
        lines.push("    const resolvedContext = context ?? this.setContextValue;".to_string());
        lines.push(String::new());
        lines.push("    if (!resolvedUser || !resolvedUser.id || (typeof resolvedUser.id === 'string' && resolvedUser.id.trim() === '')) {".to_string());
        lines.push("      return null;".to_string());
        lines.push("    }".to_string());
        lines.push(String::new());
        lines.push("    return {".to_string());
        lines.push("      targetingKey: resolvedUser.id,".to_string());
        lines.push("      ...this.flattenUserAttributes(resolvedUser),".to_string());
        lines.push("      ...this.flattenContextAttributes(resolvedContext)".to_string());
        lines.push("    };".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push(
            "  private flattenUserAttributes(user: User): Record<string, unknown> {".to_string(),
        );
        lines.push("    const attrs: Record<string, unknown> = {};".to_string());
        lines.push("    for (const [key, value] of Object.entries(user)) {".to_string());
        lines.push("      if (key !== \"id\") {".to_string());
        lines.push("        attrs[`user.${key}`] = value;".to_string());
        lines.push("      }".to_string());
        lines.push("    }".to_string());
        lines.push("    return attrs;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push(
            "  private flattenContextAttributes(context?: Context): Record<string, unknown> {"
                .to_string(),
        );
        lines.push("    if (!context) return {};".to_string());
        lines.push("    const attrs: Record<string, unknown> = {};".to_string());
        lines.push("    for (const [key, value] of Object.entries(context)) {".to_string());
        lines.push("      attrs[`context.${key}`] = value;".to_string());
        lines.push("    }".to_string());
        lines.push("    return attrs;".to_string());
        lines.push("  }".to_string());
        lines.push("}".to_string());
        lines.push(String::new());
        lines.push("export const evaluator = new Evaluator();".to_string());
        lines.push(String::new());
        lines.push("// Re-export types".to_string());
        lines.push(
            "export type { User, Context, FlagName, FlagReturnTypes } from './types';".to_string(),
        );

        lines.join("\n")
    }

    /// Generate method for a single flag
    fn generate_flag_method(&self, lines: &mut Vec<String>, flag: &Value) {
        let flag_name = flag.get("name").and_then(|n| n.as_str()).unwrap_or("");
        let method_name = Self::to_camel_case(flag_name);
        let snake_name = flag_name;
        let flag_type = flag
            .get("type")
            .and_then(|t| t.as_str())
            .unwrap_or("boolean");
        let default_value = Self::get_default_value(flag);
        let default_value_str = Self::format_default_value(default_value);
        let return_type = if flag_type == "boolean" {
            "boolean".to_string()
        } else {
            Self::get_variation_type_name(flag_name)
        };

        // TypeScript overloads
        lines.push("  // Overload 1: No parameters (uses setContext)".to_string());
        lines.push(format!(
            "  async {}(): Promise<{}>;",
            method_name, return_type
        ));
        lines.push("  // Overload 2: User only".to_string());
        lines.push(format!(
            "  async {}(user: User): Promise<{}>;",
            method_name, return_type
        ));
        lines.push("  // Overload 3: User + Context".to_string());
        lines.push(format!(
            "  async {}(user: User, context: Context): Promise<{}>;",
            method_name, return_type
        ));
        lines.push("  // Implementation".to_string());
        lines.push(format!(
            "  async {}(user?: User, context?: Context): Promise<{}> {{",
            method_name, return_type
        ));
        lines.push("    await this.ensureInitialized();".to_string());
        lines.push(String::new());
        lines.push("    try {".to_string());
        lines.push("      const evalContext = this.resolveContext(user, context);".to_string());
        lines.push("      if (!evalContext) {".to_string());
        lines.push(format!("        return {};", default_value_str));
        lines.push("      }".to_string());
        lines.push(String::new());

        if flag_type == "boolean" {
            lines.push(
                "      const result = await this.provider.resolveBooleanEvaluation(".to_string(),
            );
            lines.push(format!("        '{}',", snake_name));
            lines.push(format!("        {},", default_value_str));
            lines.push("        evalContext".to_string());
            lines.push("      );".to_string());
            lines.push(String::new());
            lines.push("      if (result.errorCode) {".to_string());
            lines.push(format!("        return {};", default_value_str));
            lines.push("      }".to_string());
            lines.push(String::new());
            lines.push("      return result.value;".to_string());
        } else {
            // Multivariate flag
            let default_str = default_value.as_str().unwrap_or("");
            lines.push(
                "      const result = await this.provider.resolveStringEvaluation(".to_string(),
            );
            lines.push(format!("        '{}',", snake_name));
            lines.push(format!("        '{}',", default_str));
            lines.push("        evalContext".to_string());
            lines.push("      );".to_string());
            lines.push(String::new());
            lines.push("      if (result.errorCode) {".to_string());
            lines.push(format!(
                "        return '{}' as {};",
                default_str, return_type
            ));
            lines.push("      }".to_string());
            lines.push(String::new());
            lines.push(format!("      return result.value as {};", return_type));
        }

        lines.push("    } catch (error) {".to_string());
        lines.push(format!("      return {};", default_value_str));
        lines.push("    }".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
    }

    /// Generate batch evaluation methods
    fn generate_batch_methods(&self, lines: &mut Vec<String>, flags: &[Value]) {
        let flag_names: Vec<String> = flags
            .iter()
            .filter_map(|f| f.get("name").and_then(|n| n.as_str()))
            .map(Self::to_camel_case)
            .collect();

        // evaluateBatch method
        lines.push("  async evaluateBatch<T extends readonly FlagName[]>(".to_string());
        lines.push("    flagNames: T,".to_string());
        lines.push("    user?: User,".to_string());
        lines.push("    context?: Context".to_string());
        lines.push("  ): Promise<{".to_string());
        lines.push("    [K in T[number]]: FlagReturnTypes[K]".to_string());
        lines.push("  }> {".to_string());
        lines.push("    await this.ensureInitialized();".to_string());
        lines.push(String::new());
        lines.push("    try {".to_string());
        lines.push("      const evalContext = this.resolveContext(user, context);".to_string());
        lines.push("      if (!evalContext) {".to_string());
        lines.push("        return this.getDefaults(flagNames) as any;".to_string());
        lines.push("      }".to_string());
        lines.push(String::new());
        lines.push("      const results: Record<string, any> = {};".to_string());
        lines.push("      for (const camelName of flagNames) {".to_string());
        lines.push("        const snakeName = this.toSnakeCase(camelName);".to_string());
        lines.push("        const flagInfo = this.getFlagInfo(camelName);".to_string());
        lines.push("        if (!flagInfo) {".to_string());
        lines.push("          results[camelName] = this.getDefaultForFlag(camelName);".to_string());
        lines.push("          continue;".to_string());
        lines.push("        }".to_string());
        lines.push(String::new());
        lines.push("        try {".to_string());
        lines.push("          if (flagInfo.type === \"boolean\") {".to_string());
        lines.push(
            "            const result = await this.provider.resolveBooleanEvaluation(".to_string(),
        );
        lines.push("              snakeName,".to_string());
        lines.push("              flagInfo.defaultValue as boolean,".to_string());
        lines.push("              evalContext".to_string());
        lines.push("            );".to_string());
        lines.push("            results[camelName] = result.errorCode ? flagInfo.defaultValue : result.value;".to_string());
        lines.push("          } else {".to_string());
        lines.push(
            "            const result = await this.provider.resolveStringEvaluation(".to_string(),
        );
        lines.push("              snakeName,".to_string());
        lines.push("              flagInfo.defaultValue as string,".to_string());
        lines.push("              evalContext".to_string());
        lines.push("            );".to_string());
        lines.push("            results[camelName] = result.errorCode ? flagInfo.defaultValue : (result.value as any);".to_string());
        lines.push("          }".to_string());
        lines.push("        } catch {".to_string());
        lines.push("          results[camelName] = this.getDefaultForFlag(camelName);".to_string());
        lines.push("        }".to_string());
        lines.push("      }".to_string());
        lines.push(String::new());
        lines.push("      return results as { [K in T[number]]: FlagReturnTypes[K] };".to_string());
        lines.push("    } catch {".to_string());
        lines.push("      return this.getDefaults(flagNames) as any;".to_string());
        lines.push("    }".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  async evaluateAll(".to_string());
        lines.push("    user?: User,".to_string());
        lines.push("    context?: Context".to_string());
        lines.push("  ): Promise<FlagReturnTypes> {".to_string());
        let flag_names_str: Vec<String> = flag_names.iter().map(|n| format!("'{}'", n)).collect();
        lines.push(format!(
            "    const flagNames: FlagName[] = [{}];",
            flag_names_str.join(", ")
        ));
        lines.push(
            "    return this.evaluateBatch(flagNames as readonly FlagName[], user, context);"
                .to_string(),
        );
        lines.push("  }".to_string());
        lines.push(String::new());

        // Helper methods
        lines.push(
            "  private getDefaults(flagNames: readonly FlagName[]): Partial<FlagReturnTypes> {"
                .to_string(),
        );
        lines.push("    const defaults: Partial<FlagReturnTypes> = {};".to_string());
        lines.push("    for (const flagName of flagNames) {".to_string());
        lines.push(
            "      defaults[flagName] = this.getDefaultForFlag(flagName) as any;".to_string(),
        );
        lines.push("    }".to_string());
        lines.push("    return defaults;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push(
            "  private getDefaultForFlag(flagName: FlagName): FlagReturnTypes[FlagName] {"
                .to_string(),
        );
        lines.push("    const flagInfo = this.getFlagInfo(flagName);".to_string());
        lines.push("    if (!flagInfo) {".to_string());
        lines.push("      return false as any;".to_string());
        lines.push("    }".to_string());
        lines.push("    return flagInfo.defaultValue as any;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  private getFlagInfo(flagName: FlagName): { type: string; defaultValue: string | boolean; returnType: string } | null {".to_string());
        lines.push("    const flagInfoMap: Record<FlagName, { type: string; defaultValue: string | boolean; returnType: string }> = {".to_string());
        for flag in flags {
            if let Some(flag_name) = flag.get("name").and_then(|n| n.as_str()) {
                let camel_name = Self::to_camel_case(flag_name);
                let flag_type = flag
                    .get("type")
                    .and_then(|t| t.as_str())
                    .unwrap_or("boolean");
                let default_value = Self::get_default_value(flag);
                let default_value_str = Self::format_default_value(default_value);
                let return_type = if flag_type == "boolean" {
                    "boolean".to_string()
                } else {
                    Self::get_variation_type_name(flag_name)
                };
                lines.push(format!(
                    "      '{}': {{ type: '{}', defaultValue: {}, returnType: '{}' }},",
                    camel_name, flag_type, default_value_str, return_type
                ));
            }
        }
        lines.push("    };".to_string());
        lines.push("    return flagInfoMap[flagName] || null;".to_string());
        lines.push("  }".to_string());
        lines.push(String::new());
        lines.push("  private toSnakeCase(camelCase: string): string {".to_string());
        lines.push(
            "    return camelCase.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);"
                .to_string(),
        );
        lines.push("  }".to_string());
        lines.push(String::new());
    }

    /// Generate package.json for the generated SDK
    fn generate_package_json(&self) -> String {
        r#"{
  "name": "generated-flags",
  "version": "0.1.0",
  "main": "index.js",
  "types": "index.d.ts",
  "dependencies": {
    "@controlpath/runtime": "^0.1.0",
    "@openfeature/server-sdk": "^1.20.1"
  }
}"#
        .to_string()
    }
}

impl Generator for TypeScriptGenerator {
    fn generate(&self, definitions: &Value, output_dir: &Path) -> CliResult<()> {
        // Create output directory if it doesn't exist
        fs::create_dir_all(output_dir)
            .map_err(|e| CliError::Message(format!("Failed to create output directory: {e}")))?;

        // Generate types.ts
        let types_content = self.generate_types(definitions);
        fs::write(output_dir.join("types.ts"), types_content)
            .map_err(|e| CliError::Message(format!("Failed to write types.ts: {e}")))?;

        // Generate index.ts
        let index_content = self.generate_evaluator(definitions);
        fs::write(output_dir.join("index.ts"), index_content)
            .map_err(|e| CliError::Message(format!("Failed to write index.ts: {e}")))?;

        // Generate package.json
        let package_json_content = self.generate_package_json();
        fs::write(output_dir.join("package.json"), package_json_content)
            .map_err(|e| CliError::Message(format!("Failed to write package.json: {e}")))?;

        Ok(())
    }
}
