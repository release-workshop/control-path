/*!
 * Generated by controlpath generate-sdk
 * DO NOT EDIT - This file is auto-generated
 */

import { Provider } from '@controlpath/runtime';
import { EvaluationContext } from '@openfeature/server-sdk';
import type { User, Context, FlagName, FlagReturnTypes } from './types';
{% if has_variations %}
{% for variation_type in variation_types %}
import type { {{ variation_type.name }} } from './types';
{% endfor %}
{% endif %}

export class Evaluator {
  private provider: Provider;
  private initialized: boolean = false;
  private setUser?: User;
  private setContextValue?: Context;

  constructor() {
    this.provider = new Provider();
  }

  async init(options?: { artifact?: string }): Promise<void> {
    if (options?.artifact) {
      await this.provider.loadArtifact(options.artifact);
    }
    this.initialized = true;
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.init();
    }
  }

  setContext(user: User, context?: Context): void {
    this.setUser = user;
    this.setContextValue = context;
  }

  clearContext(): void {
    this.setUser = undefined;
    this.setContextValue = undefined;
  }

  setLogger(logger: { error: (msg: string, data?: any) => void; warn: (msg: string, data?: any) => void; info: (msg: string, data?: any) => void; debug: (msg: string, data?: any) => void }): void {
    const loggingHook: any = {
      before: (ctx: any) => {
        logger.debug(`Evaluating flag: ${ctx.flagKey}`, { flagKey: ctx.flagKey, targetingKey: ctx.targetingKey });
      },
      after: (ctx: any, result: any) => {
        logger.info(`Flag evaluated: ${ctx.flagKey}`, { flagKey: ctx.flagKey, value: result.value, reason: result.reason, variant: result.variant });
      },
      error: (ctx: any, error: Error) => {
        logger.error(`Flag evaluation error: ${ctx.flagKey}`, { flagKey: ctx.flagKey, error: error.message, stack: error.stack });
      },
    };
    (this.provider.hooks as any[]).push(loggingHook);
  }

  setTracer(tracer: { startSpan: (name: string) => { setAttribute: (key: string, value: string | number | boolean) => void; addEvent: (name: string, attributes?: Record<string, string | number | boolean>) => void; end: () => void } }): void {
    const tracingHook: any = {
      before: (ctx: any) => {
        const span = tracer.startSpan(`flag.evaluate.${ctx.flagKey}`);
        span.setAttribute('flag.key', ctx.flagKey);
        if (ctx.targetingKey) span.setAttribute('user.id', ctx.targetingKey);
        (ctx as any).__span = span;
      },
      after: (ctx: any, result: any) => {
        const span = (ctx as any).__span;
        if (span) {
          span.setAttribute('flag.value', String(result.value));
          span.setAttribute('flag.reason', result.reason || 'UNKNOWN');
          if (result.variant) span.setAttribute('flag.variant', result.variant);
          span.addEvent('flag.evaluated', { value: String(result.value), reason: result.reason || 'UNKNOWN' });
          span.end();
        }
      },
      error: (ctx: any, error: Error) => {
        const span = (ctx as any).__span;
        if (span) {
          span.setAttribute('error', true);
          span.setAttribute('error.message', error.message);
          span.addEvent('flag.error', { message: error.message });
          span.end();
        }
      },
      finally: (ctx: any) => {
        const span = (ctx as any).__span;
        if (span) {
          try {
            span.end();
          } catch {
            // Span already ended, ignore
          }
        }
      },
    };
    (this.provider.hooks as any[]).push(tracingHook);
  }

  setMetrics(metrics: { increment: (name: string, tags?: Record<string, string>) => void; gauge: (name: string, value: number, tags?: Record<string, string>) => void }): void {
    const metricsHook: any = {
      before: (ctx: any) => {
        (ctx as any).__startTime = Date.now();
      },
      after: (ctx: any, result: any) => {
        const startTime = (ctx as any).__startTime;
        const duration = startTime ? Date.now() - startTime : 0;
        metrics.increment('flag.evaluations', { flag: ctx.flagKey, reason: result.reason || 'UNKNOWN' });
        metrics.gauge('flag.evaluation.duration_ms', duration, { flag: ctx.flagKey });
        if (result.variant) {
          metrics.increment('flag.variants', { flag: ctx.flagKey, variant: result.variant });
        }
      },
      error: (ctx: any, error: Error) => {
        metrics.increment('flag.evaluations', { flag: ctx.flagKey, reason: 'ERROR' });
        metrics.increment('flag.errors', { flag: ctx.flagKey, error: error.name });
      },
    };
    (this.provider.hooks as any[]).push(metricsHook);
  }

{% for flag in flags %}
  // Overload 1: No parameters (uses setContext)
  async {{ flag.method_name }}(): Promise<{{ flag.return_type }}>;
  // Overload 2: User only
  async {{ flag.method_name }}(user: User): Promise<{{ flag.return_type }}>;
  // Overload 3: User + Context
  async {{ flag.method_name }}(user: User, context: Context): Promise<{{ flag.return_type }}>;
  // Implementation
  async {{ flag.method_name }}(user?: User, context?: Context): Promise<{{ flag.return_type }}> {
    await this.ensureInitialized();

    try {
      const evalContext = this.resolveContext(user, context);
      if (!evalContext) {
        return {{ flag.default_value }};
      }

{% if flag.flag_type == "boolean" %}
      const result = await this.provider.resolveBooleanEvaluation(
        '{{ flag.snake_name }}',
        {{ flag.default_value }},
        evalContext
      );

      if (result.errorCode) {
        return {{ flag.default_value }};
      }

      return result.value;
{% else %}
      const result = await this.provider.resolveStringEvaluation(
        '{{ flag.snake_name }}',
        '{{ flag.default_string }}',
        evalContext
      );

      if (result.errorCode) {
        return '{{ flag.default_string }}' as {{ flag.return_type }};
      }

      return result.value as {{ flag.return_type }};
{% endif %}
    } catch (error) {
      return {{ flag.default_value }};
    }
  }

{% endfor %}
  async evaluateBatch<T extends readonly FlagName[]>(
    flagNames: T,
    user?: User,
    context?: Context
  ): Promise<{
    [K in T[number]]: FlagReturnTypes[K]
  }> {
    await this.ensureInitialized();

    try {
      const evalContext = this.resolveContext(user, context);
      if (!evalContext) {
        return this.getDefaults(flagNames) as any;
      }

      const results: Record<string, any> = {};
      for (const camelName of flagNames) {
        const snakeName = this.toSnakeCase(camelName);
        const flagInfo = this.getFlagInfo(camelName);
        if (!flagInfo) {
          results[camelName] = this.getDefaultForFlag(camelName);
          continue;
        }

        try {
          if (flagInfo.type === "boolean") {
            const result = await this.provider.resolveBooleanEvaluation(
              snakeName,
              flagInfo.defaultValue as boolean,
              evalContext
            );
            results[camelName] = result.errorCode ? flagInfo.defaultValue : result.value;
          } else {
            const result = await this.provider.resolveStringEvaluation(
              snakeName,
              flagInfo.defaultValue as string,
              evalContext
            );
            results[camelName] = result.errorCode ? flagInfo.defaultValue : (result.value as any);
          }
        } catch {
          results[camelName] = this.getDefaultForFlag(camelName);
        }
      }

      return results as { [K in T[number]]: FlagReturnTypes[K] };
    } catch {
      return this.getDefaults(flagNames) as any;
    }
  }

  async evaluateAll(
    user?: User,
    context?: Context
  ): Promise<FlagReturnTypes> {
    const flagNames: FlagName[] = [{% for name in flag_names %}{% if not loop.first %}, {% endif %}{{ name }}{% endfor %}];
    return this.evaluateBatch(flagNames as readonly FlagName[], user, context);
  }

  private getDefaults(flagNames: readonly FlagName[]): Partial<FlagReturnTypes> {
    const defaults: Partial<FlagReturnTypes> = {};
    for (const flagName of flagNames) {
      defaults[flagName] = this.getDefaultForFlag(flagName) as any;
    }
    return defaults;
  }

  private getDefaultForFlag(flagName: FlagName): FlagReturnTypes[FlagName] {
    const flagInfo = this.getFlagInfo(flagName);
    if (!flagInfo) {
      return false as any;
    }
    return flagInfo.defaultValue as any;
  }

  private getFlagInfo(flagName: FlagName): { type: string; defaultValue: string | boolean; returnType: string } | null {
    const flagInfoMap: Record<FlagName, { type: string; defaultValue: string | boolean; returnType: string }> = {
{% for flag in flags %}
      '{{ flag.camel_name }}': { type: '{{ flag.flag_type }}', defaultValue: {{ flag.default_value }}, returnType: '{{ flag.return_type }}' },
{% endfor %}
    };
    return flagInfoMap[flagName] || null;
  }

  private toSnakeCase(camelCase: string): string {
    return camelCase.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }

  private resolveContext(user?: User, context?: Context): EvaluationContext | null {
    const resolvedUser = user ?? this.setUser;
    const resolvedContext = context ?? this.setContextValue;

    if (!resolvedUser || !resolvedUser.id || (typeof resolvedUser.id === 'string' && resolvedUser.id.trim() === '')) {
      return null;
    }

    return {
      targetingKey: resolvedUser.id,
      ...this.flattenUserAttributes(resolvedUser),
      ...this.flattenContextAttributes(resolvedContext)
    };
  }

  private flattenUserAttributes(user: User): Record<string, unknown> {
    const attrs: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(user)) {
      if (key !== "id") {
        attrs[`user.${key}`] = value;
      }
    }
    return attrs;
  }

  private flattenContextAttributes(context?: Context): Record<string, unknown> {
    if (!context) return {};
    const attrs: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(context)) {
      attrs[`context.${key}`] = value;
    }
    return attrs;
  }
}

export const evaluator = new Evaluator();

// Re-export types
export type { User, Context, FlagName, FlagReturnTypes } from './types';
<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>
read_file
