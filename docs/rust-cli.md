# Rust CLI Usage Documentation

This document describes how to use the Control Path Rust CLI (`controlpath`).

## Installation

### From Source

Build from the repository:

```bash
cd control-path
cargo build --release --bin controlpath
```

The binary will be located at `target/release/controlpath`.

### Distribution

The CLI is distributed as a native binary for:
- Linux (x86_64)
- macOS (x86_64, ARM64)
- Windows (x86_64)

## Commands

### `validate`

Validate flag definitions and deployment files against JSON schemas.

#### Usage

```bash
controlpath validate [OPTIONS]
```

#### Options

- `--definitions <FILE>`: Path to flag definitions file (default: `flags.definitions.yaml`)
- `--deployment <FILE>`: Path to deployment file
- `--env <ENV>`: Environment name (uses `.controlpath/<env>.deployment.yaml`)
- `--all`: Validate all files (auto-detect `flags.definitions.yaml` and `.controlpath/*.deployment.yaml`)

#### Examples

Validate a specific definitions file:

```bash
controlpath validate --definitions flags.definitions.yaml
```

Validate a specific deployment file:

```bash
controlpath validate --deployment .controlpath/production.deployment.yaml
```

Validate using environment name:

```bash
controlpath validate --env production
```

Validate all files in the current directory:

```bash
controlpath validate --all
```

Auto-detect and validate (if files exist):

```bash
controlpath validate
```

#### Exit Codes

- `0`: Validation passed
- `1`: Validation failed or no files found

### `compile`

Compile deployment files to AST artifacts.

#### Usage

```bash
controlpath compile [OPTIONS]
```

#### Options

- `--deployment <FILE>`: Path to deployment file
- `--env <ENV>`: Environment name (uses `.controlpath/<env>.deployment.yaml`)
- `--output <FILE>`: Output path for AST file (default: inferred from deployment path)
- `--definitions <FILE>`: Path to flag definitions file (default: `flags.definitions.yaml`)

#### Examples

Compile using environment name:

```bash
controlpath compile --env production
```

This will:
1. Read `.controlpath/production.deployment.yaml`
2. Read `flags.definitions.yaml`
3. Compile to `.controlpath/production.ast`

Compile with explicit paths:

```bash
controlpath compile \
  --definitions flags.definitions.yaml \
  --deployment .controlpath/production.deployment.yaml \
  --output .controlpath/production.ast
```

Compile with custom output path:

```bash
controlpath compile --env production --output dist/production.ast
```

#### Exit Codes

- `0`: Compilation succeeded
- `1`: Compilation failed

### `init`

Initialize a new Control Path project.

#### Usage

```bash
controlpath init [OPTIONS]
```

#### Options

- `--force`: Overwrite existing files
- `--example-flags`: Create example flags (default: true if no existing files)
- `--no-examples`: Skip creating example files

#### Examples

Initialize a new project:

```bash
controlpath init
```

This creates:
- `flags.definitions.yaml` (with example flag)
- `.controlpath/production.deployment.yaml`

Initialize without examples:

```bash
controlpath init --no-examples
```

Initialize and overwrite existing files:

```bash
controlpath init --force
```

#### Exit Codes

- `0`: Initialization succeeded
- `1`: Initialization failed

## File Organization

### Standard Structure

```
project-root/
├── flags.definitions.yaml          # Flag definitions (owned by Engineering)
├── .controlpath/                   # Deployment files directory
│   ├── production.deployment.yaml  # Production deployment rules
│   ├── staging.deployment.yaml     # Staging deployment rules
│   ├── production.ast              # Compiled AST artifacts
│   └── staging.ast
└── ...
```

### Flag Definitions File

Location: `flags.definitions.yaml` (or custom path via `--definitions`)

Owned by: Engineering team

Contains:
- Flag type definitions
- Default values
- Variations (for multivariate flags)
- Lifecycle information

### Deployment Files

Location: `.controlpath/<env>.deployment.yaml`

Owned by: Product/DevOps team

Contains:
- Environment-specific rules
- Targeting rules (`when` clauses)
- Rollout configurations
- Segment definitions

### AST Artifacts

Location: `.controlpath/<env>.ast` (or custom path via `--output`)

Generated by: `controlpath compile`

Contains:
- Compiled MessagePack binary
- All flag rules
- Segment definitions
- Optional signature

## Workflow Examples

### Basic Workflow

1. **Initialize project:**
   ```bash
   controlpath init
   ```

2. **Add flags:**
   Edit `flags.definitions.yaml` to add new flags.

3. **Configure deployment:**
   Edit `.controlpath/production.deployment.yaml` to add rules.

4. **Validate:**
   ```bash
   controlpath validate --all
   ```

5. **Compile:**
   ```bash
   controlpath compile --env production
   ```

6. **Use AST artifact:**
   The compiled `.controlpath/production.ast` file can be used by the runtime SDK.

### Multi-Environment Workflow

1. **Create deployment files for each environment:**
   ```bash
   # Create production deployment
   cp .controlpath/production.deployment.yaml .controlpath/staging.deployment.yaml
   # Edit staging.deployment.yaml
   ```

2. **Compile each environment:**
   ```bash
   controlpath compile --env production
   controlpath compile --env staging
   ```

3. **Validate all environments:**
   ```bash
   controlpath validate --all
   ```

### CI/CD Integration

Example GitHub Actions workflow:

```yaml
name: Compile Flags

on:
  push:
    branches: [main]
    paths:
      - 'flags.definitions.yaml'
      - '.controlpath/**/*.deployment.yaml'

jobs:
  compile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Validate
        run: cargo run --bin controlpath -- validate --all
      - name: Compile Production
        run: cargo run --bin controlpath -- compile --env production
      - name: Compile Staging
        run: cargo run --bin controlpath -- compile --env staging
      - name: Upload Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: ast-artifacts
          path: .controlpath/*.ast
```

## Error Messages

### Validation Errors

When validation fails, the CLI provides clear error messages:

```
✗ Validation failed
  Error: Schema validation failed: /flags/0/name: must be a string
```

### Compilation Errors

Compilation errors include context:

```
✗ Compilation failed
  Error: Expression parsing error: Expected expression after AND operator
    Expression: "user.role == 'admin' AND"
    Position: 28
```

### File Not Found Errors

Clear messages when files are missing:

```
✗ Compilation failed
  Error: Failed to read definitions file: No such file or directory (os error 2)
```

## Performance

The Rust CLI is optimized for performance:

- **Fast Startup**: Native binary, no runtime overhead
- **Fast Compilation**: Efficient Rust implementation
- **Small Binary**: Optimized release builds
- **Low Memory**: Efficient memory usage

## Troubleshooting

### "No such file or directory"

Ensure files exist and paths are correct:

```bash
# Check if files exist
ls -la flags.definitions.yaml
ls -la .controlpath/*.deployment.yaml
```

### "Validation failed"

Check your YAML syntax and schema compliance:

```bash
# Validate with verbose output
controlpath validate --all
```

### "Compilation failed"

Check for:
- Invalid expressions in `when` clauses
- Missing flag definitions
- Type mismatches

## See Also

- [Rust API Documentation](./rust-api.md)
- [Architecture Documentation](../control-path-next/ARCHITECTURE.md)

